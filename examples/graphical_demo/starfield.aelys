needs std.io
needs std.bytes
needs std.time
needs std.sys
needs std.convert
needs std.math

let W = 160
let H = 90
let ROWS = H / 2
let NUM_STARS = 400
let ESC = convert.chr(27)
let HALF = convert.chr(9600)

@no_gc
fn run() {
    let fb_r = bytes.alloc(W * H)
    let fb_g = bytes.alloc(W * H)
    let fb_b = bytes.alloc(W * H)

    let star_x = bytes.alloc(NUM_STARS * 4)
    let star_y = bytes.alloc(NUM_STARS * 4)
    let star_z = bytes.alloc(NUM_STARS * 4)

    for i in 0..NUM_STARS {
        let x = sys.random_int(-500, 500)
        let y = sys.random_int(-500, 500)
        let z = sys.random_int(1, 1000)
        bytes.write_i32(star_x, i * 4, x)
        bytes.write_i32(star_y, i * 4, y)
        bytes.write_i32(star_z, i * 4, z)
    }

    io.print_inline(ESC + "[?25l")
    io.print_inline(ESC + "[2J")

    let cx = W / 2
    let cy = H / 2
    let speed = 8

    for frame in 0..600 {
        bytes.fill(fb_r, 0, W * H, 0)
        bytes.fill(fb_g, 0, W * H, 0)
        bytes.fill(fb_b, 0, W * H, 0)

        for i in 0..NUM_STARS {
            let mut z = bytes.read_i32(star_z, i * 4)
            z = z - speed
            if z <= 0 {
                bytes.write_i32(star_x, i * 4, sys.random_int(-500, 500))
                bytes.write_i32(star_y, i * 4, sys.random_int(-500, 500))
                z = 1000
            }
            bytes.write_i32(star_z, i * 4, z)

            let x = bytes.read_i32(star_x, i * 4)
            let y = bytes.read_i32(star_y, i * 4)

            let sx = cx + (x * 200) / z
            let sy = cy + (y * 200) / z

            if sx >= 0 and sx < W and sy >= 0 and sy < H {
                let bright = 255 - (z * 255) / 1000
                let mut b = 0
                if bright > 0 { b = bright }
                if b > 255 { b = 255 }

                let idx = sy * W + sx
                let old = bytes.read_u8(fb_r, idx)
                if b > old {
                    bytes.write_u8(fb_r, idx, b)
                    bytes.write_u8(fb_g, idx, b)
                    bytes.write_u8(fb_b, idx, b)
                }

                if z < 300 and sx > 0 and sx < W - 1 {
                    let trail = b / 3
                    let idx1 = sy * W + sx - 1
                    let idx2 = sy * W + sx + 1
                    if bytes.read_u8(fb_r, idx1) < trail {
                        bytes.write_u8(fb_r, idx1, trail)
                        bytes.write_u8(fb_g, idx1, trail)
                        bytes.write_u8(fb_b, idx1, trail / 2)
                    }
                    if bytes.read_u8(fb_r, idx2) < trail {
                        bytes.write_u8(fb_r, idx2, trail)
                        bytes.write_u8(fb_g, idx2, trail)
                        bytes.write_u8(fb_b, idx2, trail / 2)
                    }
                }
            }
        }

        io.print_inline(ESC + "[H")
        for row in 0..ROWS {
            let y1 = row * 2
            let y2 = y1 + 1
            for px in 0..W {
                let idx1 = y1 * W + px
                let idx2 = y2 * W + px
                let r1 = bytes.read_u8(fb_r, idx1)
                let g1 = bytes.read_u8(fb_g, idx1)
                let b1 = bytes.read_u8(fb_b, idx1)
                let r2 = bytes.read_u8(fb_r, idx2)
                let g2 = bytes.read_u8(fb_g, idx2)
                let b2 = bytes.read_u8(fb_b, idx2)
                io.print_inline(ESC + "[38;2;" + convert.to_string(r1) + ";" + convert.to_string(g1) + ";" + convert.to_string(b1) + ";48;2;" + convert.to_string(r2) + ";" + convert.to_string(g2) + ";" + convert.to_string(b2) + "m" + HALF)
            }
            io.print_inline(ESC + "[0m")
            io.print("")
        }
        io.flush()
        time.sleep(25)
    }

    io.print_inline(ESC + "[?25h")
    io.print_inline(ESC + "[2J" + ESC + "[H")

    bytes.free(fb_r)
    bytes.free(fb_g)
    bytes.free(fb_b)
    bytes.free(star_x)
    bytes.free(star_y)
    bytes.free(star_z)
}

run()
io.print("Starfield complete!")
